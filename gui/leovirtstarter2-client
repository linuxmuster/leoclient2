#!/usr/bin/perl -w
# This Script (leovirtstarter2-client) was created by Rüdiger Beck
# It is released under the GPL Version 3
# For Bugs send mail to (jeffbeck-at-web.de)

use strict;
use Glib qw/TRUE FALSE/;
use Gtk2 '-init';
use Getopt::Long;
use utf8;
use File::Basename;
use Log::Log4perl qw(:easy);
use Sys::Hostname;
use Data::Dumper;
use IO::Interface::Simple;

# todo
# read config into hash see line 84 ?????
# create zenity chooser with hash
# set $vm if only ONE vm is there
# start using snapshots
# Haken beim starten (Rechner starten / Virtualbox starten)


#************************************************************
#************************************************************
#************************************************************
#************************************************************
#************************************************************
#************************************************************
# old serverConf stuff

############################################################                    
# ram                                                                           
############################################################                    
my @ram_steps=("192",
            "256",
            "384",
            "512",
            "768",
            "1024",
            "1536",
            "2048",
            "3072",
            "4096",
            "6144",
            "8192",
            "12288");

my $min_host_ram="256";
my $max_guest_ram="2048";

############################################################                    
# virtualbox                                                                    
############################################################                    
# the BASE IMAGE, that is never changed                                         
# where must the base image be on the client:                                   
#my $base_image_target="/virtual/vdi/winXP-2010.vdi";
# where in the image directory can the base image be found:                     
# (relative to $snapshot_file_dir below)                                        
#my $base_image_source="base/winXP-2010.vdi";

#in Snapshot-store/base
my $base_image_size="2468409856"; # as seen with 'ls -l'  

# the base image


# the SNAPSHOTS                                                                 
#my $snapshot_file_dir="/virtual/Machines/winXP-2010/Snapshots";
my $snapshot_file_name="{8c816439-1e6e-430f-9865-db7a2a96206f}.vdi";

# calculate path to network.conf
my $network_conf="";
# is a network.conf used? 0=not used, 1=used, patch network settings for vm
my $network_patch=0;
my $network_vbox_command="";


#####################################2#######################                    
# logging                                                                       
############################################################                    
my $server_popularity_log_file=".log-popularity";

# old server conf end
#************************************************************
#************************************************************
#************************************************************
#************************************************************
#************************************************************
#************************************************************



# Contains information about snapshots
my %snapshots=();

my $search_dir_local="";


############################################################
# new config


# This will be read from /etc/leoclient2/machines.conf
my @snapshot_search_dirs=();
my @snapshot_search_dirs_remote=();
# this is double ??? should be removed
my $snapshot_search_dir_client="";

# Base Image is calculated
my $base_image_source="";
my $base_image_target="";

# Caches on the clients
# path to cache.conf is calculated:
my $cache_conf_path="";
# path to the caches from cache.conf:
my @cache_dirs=();
# size of the caches in MB from cache.conf:
my @cache_dirs_size=();

# Snapshots
# in which directory is the snapshot that is  used as the
# second entry
my $snapshot_default="standard";
my $snapshot_file_dir="";




############################################################

# fill this hash with configs
# vm -> abs_path
my %vm=();
my %vm_uuid=();
my $vm_path_abs="";

# config dir
my $conf="/etc/leoclient2";
my $conf_machines=$conf."/machines";
my $conf_file=$conf."/machines.conf";

my @vm=();

# shell export variable for the machine
my $vm_path_export="";

# which filepath is used for the shared folder
my $home = $ENV{'HOME'};
# ????? was ist besser ?????
# vm-printer/spooler/splitter
#my $shared_home_abs=$home;
my $shared_home_abs="~/Home_auf_Server";

# get hostname
my $hostname=hostname();

# get group(=room) of host (not user)
my $host_group="";
my $host_uid = getpwnam($hostname);
my @host_entry= getpwuid($host_uid);
my $host_gid=$host_entry[3];
my ($host_room) = getgrgid($host_gid);

#my $hostname=`hostname`;
chomp($hostname);
my $on_the_go="";
# Option --vm
my $vm="";
# Option --virtualbox
my $virtualbox=0;
# Option --local-snapshots
my $local_snapshots=0;
my $clean_cache=0;
my $clean_log=0;
my $help=0;
my $info=0;
my $show_menu=0;
my $snapshot_search_dir="";
my $ignore_virtualbox=0;
my $log="/tmp/leovirtstarter2.log";
# allow everybody to log into the logfile
umask 000;
# change $INFO to $DEBUG to see more
Log::Log4perl->easy_init({ 
#                level   => $INFO,
                level   => $DEBUG,
                file    => ">>$log" } );    

#use leoclient2::leovirtstarter2;
use Filesys::Df;



# Parsen der Optionen
my $testopt=GetOptions(
           "help|h" => \$help,
           "info|i" => \$info,
           "show-menu|menu" => \$show_menu,
           "on-the-go|g=s" => \$on_the_go,
           "vm=s" => \$vm,
           "virtualbox|vbox" => \$virtualbox,
           "local-snapshots" => \$local_snapshots,
           "clean|clean-cache" => \$clean_cache,
           "clean-log" => \$clean_log,
           "ignore-virtualbox" => \$ignore_virtualbox,
           "snapshots|snapshots-search-dir|s=s" => \$snapshot_search_dir,
          );

# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);

if ($help==1){
   print('
Options
  -h  / --help
  -i  / --info (list the available machines and exit)

Power User:
  --virtualbox / --vbox
    Open the virtualbox window of the machine 
    instead of starting the machine
  --local-snapshots
    look only for snapshots in the snapshot-store of the machine
  --ignore-virtualbox (start leovirtstarter2 even if VirtualBox ist running)
    This may overwrite the virtual harddisk of a running virtual machine,
    which will therefore crash.


Development:
  --clean-cache   (clean all caches)
  --clean-log     (clean all log files)

Non-Server use:
  --on-the-go /path/to/config/file  (using another config file)
  --snapshots /path/to/zipped/snapshots (override path in config files)

');
   print "\n";
   exit;
}

# read config file /etc/leoclient2/machines.conf
open (CONFFILE, $conf_file);
while (<CONFFILE>){
   s/^ //g; # Leerzeichen am Zeilenangfang entfernen
   if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
       next;
   }
   chomp();
   if($_ eq ""){
       next;
   }
   print "machines.conf LINE:   $_\n";
   my ($option,$data)=split(/=/);
   #print "Option: $option\n";
   if($option eq "DEFAULT"){
       #print "$data\n";
       # ??????? do something with the data
#   } elsif ($option eq "CACHE"){
#       my ($path,$size)=split(/::/,$data);
#       # add a dir cache
#       $path=$path."/cache";
#       #print "PATH: >$path<\n";
#       #print "SIZE: >$size<\n";
#       push @cache_dirs, $path;
#       push @cache_dirs_size, $size;
   } elsif ($option eq "SERVERDIR"){
       print "  SERVERDIR: $data\n";
       push @snapshot_search_dirs_remote, $data;
   }
}
close CONFFILE;

# Set variables based on serverdirs
# cache.conf must be in first serverdir (????? Look in all server dirs) 
$cache_conf_path=$snapshot_search_dirs_remote[0]."/cache.conf";


# read config file /etc/leoclient2/machines.conf
open (CACHECONFFILE, $cache_conf_path);
while (<CACHECONFFILE>){
   s/^ //g; # Leerzeichen am Zeilenangfang entfernen
   if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
       next;
   }
   chomp();
   if($_ eq ""){
       next;
   }
   print "cache.conf LINE: $_\n";
   my ($cache_path,$cache_size,$range,$parameter)=split(/::/);
   if($range eq "ALLHOSTS"){
       # add a cache dir
       $cache_path=$cache_path."/cache";
       print "  CACHE_PATH:      $cache_path\n";
       print "  CACHE_SIZE:      $cache_size\n";
       print "  CACHE_RANGE:     $range\n";
       print "  CACHE_PARAMETER: $parameter\n";
       push @cache_dirs, $cache_path;
       push @cache_dirs_size, $cache_size;
   } 
}
close CACHECONFFILE;



# read config dir /etc/leoclient2/machines
if (not -d $conf_machines){
    print "\nERROR: Configuration directory $conf_machines does not exist\n\n";
    exit;
} 
opendir CONFDIR, $conf_machines;
foreach my $machine (readdir CONFDIR){
    if ($machine eq "."){next};
    if ($machine eq ".."){next};
    if ($machine=~m/.conf$/){
        my $path=&get_machine_path($machine);
        $machine=~s/.conf$//g;
        $vm{$machine}=$path;
        $vm_uuid{$machine}=$path;
        push @vm, $machine;
    }
}
closedir CONFDIR;
@vm = sort @vm;


if ($info==1){
    # list machines alphabetically
    print "\nMachines listed in ${conf_machines}:\n";
        printf " %-9s| %-35s| %-19s\n",
               "Name","Snapshot-file UUID","Path";
    print "----------+------------------------------------+",
          "----------------------------\n";
    foreach my $machine (@vm){
        my $vbox_uuid=&get_vbox_uuid($machine);
        printf " %-9s|%-36s|%-20s\n",
               $machine,$vbox_uuid,$vm{$machine};
    }
    print "----------+-----------------------------------------+",
          "-----------------------\n";
    exit;
}


# List serverdirs (hide later, show only with --info ??????) 
foreach my $dir (@snapshot_search_dirs_remote){
    print "Serverdir : $dir\n";
    $snapshot_search_dir_client=$dir;
}

# List caches (hide later, show only with --info ??????) 
my $cache_count=0;
foreach my $dir (@cache_dirs){
    print "Cache dir: $dir\n";
    print "     Size: $cache_dirs_size[$cache_count] MB\n";
    $cache_count++;
}


if ($vm ne ""){
    # start vm
    #$vm_path_abs=$vm{$vm};
    #$search_dir_local=$vm_path_abs;
    ## remove last dir to fit to remote dirs
    #$search_dir_local=~s/\/$//g;
    #$search_dir_local=~s/\/${vm}$//g;
    ##system("leovirtstarter2-client --vm $vm");
    ##exit;
} elsif ($#vm==-1) {
    INFO "No machines found, aborting with gui Error\n";
    my $message="Es gibt keine Maschinen in $conf_machines!";
    system("/usr/bin/zenity --warning --text='$message'");
    exit;
} else {
    # show zenity chooser
#    my $zenity_list="/usr/bin/zenity --list --width=800 --height=400 ".
#       "--radiolist --title='Virtuelle Maschine wählen!' ".
#       "--column='' --column='Maschine' ".
#       "--column='Beschreibung' --column='Pfad' ".
#       "TRUE 'winxp' 'Windows XP' '/var/virtual/winxp' ".
#       "FALSE win7 'Windows 7' '/var/virtual/winxp2'";
    my $zenity_list="/usr/bin/zenity --list --width=800 --height=400 ".
       "--radiolist --title='Virtuelle Maschine wählen!' ".
       "--column='' --column='Maschine' ".
       "--column='Beschreibung' --column='Pfad' ";
    # add items
    foreach my $machine (@vm){
        print "  $machine --> $vm{$machine}\n";    
        $zenity_list=$zenity_list.
              "FALSE '$machine' '$machine' $vm{$machine} ";    
    }
    
    #print "$zenity_list\n";
    my $zenity_return=`$zenity_list`;
    chomp($zenity_return);
    print "Zenity return String: >$zenity_return<\n";
    if ($zenity_return eq ""){
        #  canceled
        exit;
    }
    $vm=$zenity_return;
}



# vm is chosen --> setting paths
$vm_path_abs=$vm{$vm};
$snapshot_file_dir=$vm_path_abs."/Snapshots";
$search_dir_local=$vm_path_abs;
# remove last dir to fit to remote dirs
$search_dir_local=~s/\/$//g;
$search_dir_local=~s/\/${vm}$//g;
foreach my $dir (@snapshot_search_dirs_remote){
    $base_image_source = $dir."/$vm/snapshot-store/base/".$vm.".vdi";
    print "CHECK: $base_image_source\n";
    if (-e $base_image_source){
        last;
    }
}
$base_image_target=$vm_path_abs."/".$vm.".vdi";
$network_conf=$vm_path_abs."/network.conf";
print "base_image_source: $base_image_source\n";
print "base_image_target: $base_image_target\n";
print "network.conf:      $network_conf\n";

#
#exit;

# --local-snapshots
if ($local_snapshots==1){
    # empty list of remote snapshots
    @snapshot_search_dirs_remote=();
}

@snapshot_search_dirs=($search_dir_local,@snapshot_search_dirs_remote);


# set path
if ($vm_path_abs ne ""){
#     # start a given vm
#     print "##### Starting Virtual machine $vm\n";
    $vm_path_export="export VBOX_USER_HOME=".$vm_path_abs."; ";
#     my $remove_shared_folder=$vm_path_export.
#                "/usr/bin/VBoxManage sharedfolder remove $vm --name home";
#     my $add_shared_folder=$vm_path_export.
#                "/usr/bin/VBoxManage sharedfolder add $vm ".
#                "--name home --hostpath $shared_home_abs";
#     my $start_vm=$vm_path_export."/usr/bin/VBoxManage startvm $vm --type gui";
#     my $start_vbox=$vm_path_export."/usr/bin/virtualbox";
#     print "$remove_shared_folder\n";
#     print "$add_shared_folder\n";
#     print "$start_vm\n";
#     &fix_vbox_permissions($vm_path_abs,$vm);
#     system("$remove_shared_folder");
#     system("$add_shared_folder");
#     if ($virtualbox==1){
#         system("$start_vbox");
#     } else {
#         system("$start_vm");
#     }
#     exit;
} else {
#     # just start vitualbox
#     print "   ERROR:  None of these configuration files found:\n";
#     print "   * $Conf::common_configuration_file\n";
#     print "   * $on_the_go\n";
#     system("/usr/bin/VirtualBox");
#     exit;
} 

if (-f $network_conf){
    # read config file network.conf
    $network_patch=1;
    print "Checking if network of $hostname must be patched\n";
    open (NETCONF, $network_conf);
    while (<NETCONF>){
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }
        chomp();
        if($_ eq ""){
            next;
        }
        print "network.conf LINE:   $_\n";
        my ($p_host,$p_virt_nic,$p_net_type,$p_mac,$p_nic_name)=split(/;/);
        if ($hostname eq $p_host){
        print "Patching Network: $p_host\n";
        print "  Virtual NIC:    $p_virt_nic\n";
        print "  Network type:   $p_net_type\n";
        print "  MAC :           $p_mac\n";
        print "  Interface:      $p_nic_name\n";
        my $p_option="";
        if ($p_net_type eq "nat"){
            $p_option="--natnet";
        } elsif ($p_net_type eq "bridge"){
            $p_option="--bridgeadapter";
        }
        if ($p_nic_name eq "auto"){
            my @unconfigured_ifs=();
            my @interfaces = IO::Interface::Simple->interfaces;
            for my $if (@interfaces) {
                if ($if->is_loopback){
                    print "   * $if is loopback\n";
                    next;
                }
                my $running=$if->is_running;
                if (defined $if->address and 
                    defined $if->netmask 
                    and $running==1
                   ){
                    # keep unchanged
                    print "   * $if is running (IP: ",$if->address,")\n";
                    
                } else {
                    # interface is not in use
                    print "   * $if is NOT in use\n";
                    push @unconfigured_ifs, $if;
                }
            }
            # sort unconfigured ifs
	    @unconfigured_ifs = sort  @unconfigured_ifs;
            if (defined $unconfigured_ifs[0]){
                # use the first unconfigured interface
                $p_nic_name=$unconfigured_ifs[0];
	    } else {
                print "\nERROR: No unconfigured interface found\n\n";
                exit;
            }
        }
        $network_vbox_command="/usr/bin/vboxmanage ".
                              "modifyvm $vm ".
                              "--nic${p_virt_nic} $p_net_type ".
                              "$p_option${p_virt_nic} $p_nic_name ".
                              "--macaddress$p_virt_nic $p_mac";
        print "$network_vbox_command\n";
        }
    }
    close NETCONF;
} else {
    INFO "$network_conf not found.\n";
    print "INFO: network.conf not fount at:\n ";
    print "  $network_conf\n ";
}

print "patch network:     $network_patch\n";




if ($clean_cache==1){
    INFO "Starting leovirtstarter2-client --clean-cache on $hostname";
    INFO "Cleaning the cache";
    foreach my $cache (@cache_dirs){
        INFO "Removing recursively $cache";
        if (-d $cache){
            system("rm -rf $cache || sudo rm -rf $cache");
        }
    }
    INFO "########################## Exiting ###############################";
    exit;
}


if ($clean_log==1){
    system("echo '' > $log");
    INFO "Previous logfiles cleaned by leovirtstarter2-client --clean-log";
    INFO "########################## Exiting ###############################";
    exit;
}



# Abbruch, falls virtualbox schon läuft
my $pid_string=`pgrep -f /usr/lib/virtualbox/VirtualBox`;
chomp($pid_string);
print "PID: <$pid_string>\n";
if ($pid_string ne "" and $ignore_virtualbox==0){
    print "VirtualBox is running already\n";
    my $message="<b>Oracle VM VirtualBox</b> läuft schon!\n\n".
                "Deshalb kann <b>VirtualBox Snapshotstarter</b> nicht gestartet werden.\n\n".
                "Bitte beenden Sie zuerst <b>Oracle VM VirtualBox</b>!";
    system("/usr/bin/zenity --warning --text='$message'");
    exit;
}


my $vbox_uuid=&get_vbox_uuid($vm);

print "UUID: $vbox_uuid\n";

INFO "Starting leovirtstarter2-client on $hostname";
INFO "UUID: $vbox_uuid (Max RAM: $max_guest_ram)";
my @unused=@ram_steps;
# Abhängigkeiten von Paketen: 
# libfilesys-df-perl (ubuntu 10.04)
# libglib-perl (lenny)
# libgtk2-perl

# config
# auf client bzw. server wird in /etc/leovirtstarter2/leovirtstarter2.conf
# so konfiguriert, dass es auf diesselebe Datei auf dem server verweist

# Todo:

# count how often a image was used (from cache) or downloaded
# from which server:
# log a line into the server file usage in the directory containing 
# all images:
# date::image-name::client-name/IP::user::??
# log everything into .log/leovirtstarter2-err.log
# 
# checks:
# A) no virtualbox is allowed to run, when starting another one
# B) refresh .Virtualbox, when image could not be started -> 
# start again/prompt user to refresh and start again 



# Works:
# starting from Desktop icon



# server script
# the same binary as this (pm)
#     A) zip all files
#     B) store size zip and notzipped (and md5sum)
#     C) rsync zipped files to a list of servers 
# 

# Option --pack-and-go path-to-packed-files
# benutze leovirtstarter2-client.conf mit Pfad zu vorbereiteter/gepatchter 
# leovirtstarter2-server.conf
# ersetze .VirtualBox oder patche sie (unionfs?)
# beim beenden fragen ob /virtual wieder gelöschtw werden soll
# evtl zusatzoption --link-virtual (verlinkt /virtual zum stick/Platte)


########### $app_window ########################################################
# +++++++++++++++++++++++++ $vbox ++++++++++++++++++++++++++++++++++++++++++++ #
# + ######################## $ hbox ######################################## + #
# + # +++ $hbox_starter ++++++++++++++ # +++++++ $hbox_hardware +++++++++  # + #
# + # +                              + # +                              +  # + #
# + # +                              + # + ###### $vbox_hardware #####  +  # + #
# + # +                              + # + ###### $hardware_grafik ###  +  # + #
# + # +                              +   + #                         #  +  # + #
# + # +                              + $ + #                         #  +  # + #
# + # +                              + h + #                         #  +  # + #
# + # +                              + b + #                         #  +  # + #
# + # +                              + o + #                         #  +  # + #
# + # +                              + x + ###########################  +  # + #
# + # +                              + _ +                              +  # + #
# + # +                              + s + ##### $hardware_hsep ######  +  # + #
# + # +                              + e +                              +  # + #
# + # +                              + p +                              +  # + #
# + # +                              + e +                              +  # + #
# + # +                              + r +                              +  # + #
# + # +                              + a +                              +  # + #
# + # +                              + t +                              +  # + #
# + # +                              + o +                              +  # + #
# + # +                              + r +                              +  # + #
# + # +                              +   +                              +  # + #
# + # +                              + # +                              +  # + #
# + # +                              + # +                              +  # + #
# + # +                              + # +                              +  # + #
# + # +                              + # +                              +  # + #
# + # ++++++++++++++++++++++++++++++++ # ++++++++++++++++++++++++++++++++  # + #
# + ######################################################################## + #
# +                                                                          + #
# + ######################## $vbox_seperator ############################### + #
# +                                                                          + #
# + ######################## $align -> $progress_bar ####################### + #
# + #                                                                      # + #
# + #                                                                      # + #
# + #                                                                      # + #
# + #                                                                      # + #
# + ######################################################################## + #
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #
################################################################################

# where to save selected radiobuttons
my %selected=();

my $copying_done=0; 

# weiter
# help grafik vervollständigen
# programm darf nur 1x gestartet werden
# wenns schon kopiert, dann fragen ob man abbrechen will, oder neue kopie starten



my $app_window = Gtk2::Window->new('toplevel');


# The following lists might be created automatically
my $buttons_default="Windows XP Standard";
my $buttons_as_used="Windows XP wie vorgefunden";

#my @buttons=&get_snapshots($snapshot_search_dir_client);
my @buttons=&get_snapshots(@snapshot_search_dirs);


# ??????
#print Dumper(\@snapshot_search_dirs);
#print Dumper(\%snapshots);

#exit;

@buttons=($buttons_as_used,$buttons_default,@buttons);

my @grafik_buttons=("2D",
                    "3D Beschleunigung",
                    "3D und Video Beschleunigung");
my $grafik_buttons_default="2D";

my $pb_win_get_base_zip;
my $pb_win_get_zip;
my $pb_win_start_zip;


############################################################
# Checks 
############################################################


&check_base_image($home,$on_the_go);

my ($ram_buttons_default, @ram_sizes)=&ram_sizes();

#print "\n---$ram_buttons_default---\n\n";

my %ram_mapping=();
my @ram_buttons=();
foreach my $size (@ram_sizes){
    push @ram_buttons, $size;
    my $string=$size." MB";
    $ram_mapping{$size}="$string"; 
}



# make sure all cache dirs exist
foreach my $dir (@cache_dirs){
    if (not -e $dir){
            system("mkdir -p $dir || sudo mkdir -p $dir");
            system("chmod -R 777 $dir || sudo -R chmod 777 $dir");
    }
}


INFO "Starting leovirtstarter2-client GUI on $hostname";

############################################################
# GUI
############################################################

# create programm window: app_window
# $app_window definded before check base image which shows it
$app_window->set_resizable(TRUE);
$app_window->signal_connect(destroy => \&destroy_progress);
$app_window->signal_connect('delete_event' => sub { Gtk2->main_quit; });
$app_window->set_title("Virtuelles Windows starten");
$app_window->set_border_width(0);
# Fenstergroesse
$app_window->set_size_request( 800, 600 );
# zentrieren
$app_window->set_position('center_always');


############################################################
# create vbox inside app_window and fill it:
# hbox, vbox_seperator, align, progress_bar
############################################################
my $vbox = Gtk2::VBox->new(FALSE, 5);
$vbox->set_border_width(0);
$app_window->add($vbox);
$vbox->show;



############################################################
# Drop Down Menus: machines, help, ...
############################################################
my $menu_drop_machine = new Gtk2::Menu();
my $menu_drop_help = new Gtk2::Menu();

############################################################
# Menu machine items
############################################################

# Top
my $menu_machine_top = new Gtk2::MenuItem( "Virtuelle Maschinen" );
$menu_machine_top->show();
$menu_machine_top->set_submenu( $menu_drop_machine );

# item 1
my $menu_machine_1 = new Gtk2::MenuItem( "Windows" );
$menu_drop_machine->append( $menu_machine_1 );
$menu_machine_1->signal_connect( 'activate', sub { print( "Windows\n" ); } );
$menu_machine_1->show();

# item 2
my $menu_machine_2 = new Gtk2::MenuItem( "Linux" );
$menu_drop_machine->append( $menu_machine_2 );
$menu_machine_2->signal_connect( 'activate', sub { print( "Linux\n" ); } );
$menu_machine_2->show();

# item ...


############################################################
# Help Menu
############################################################

# Top 
my $menu_help_top = new Gtk2::MenuItem( "Hilfe" );
$menu_help_top->show();
$menu_help_top->set_submenu( $menu_drop_help );

# item 1
my $menu_help_1 = new Gtk2::MenuItem( "Hilfe" );
$menu_drop_help->append( $menu_help_1 );
$menu_help_1->signal_connect( 'activate', sub { print( "Help\n" ); } );
$menu_help_1->show();

# item 2
my $menu_help_2 = new Gtk2::MenuItem( "Über" );
$menu_drop_help->append( $menu_help_2 );
$menu_help_2->signal_connect( 'activate', sub { print( "About\n" ); } );
$menu_help_2->show();

# item ...

############################################################
# Menu Bar
############################################################

# Create a menu-bar to hold the menus and add it to 
# the vbox in our main window
my $menubar = new Gtk2::MenuBar();
$vbox->pack_start( $menubar, 0, 0, 2 );
if ($show_menu==1){
    $menubar->show();
}

# And finally we append the top items of a drop down menu
# to the menu-bar 
$menubar->append( $menu_machine_top );
$menubar->append( $menu_help_top );



############################################################
# add vbox 
############################################################
# create hbox inside vbox
my $hbox = Gtk2::HBox->new(FALSE, 5);
$hbox->set_border_width(20);
# insert hbox into vbox
$vbox->add($hbox);
#$vbox->pack_start($hbox, FALSE,FALSE,5);
$hbox->show;


############################################################
# create the starter box and fill it:
# hbox_starter, hbox_seperator, $hbox_hardware
############################################################

# Chooser for the starter box
my $hbox_starter = &starter_vbox();
$hbox->add($hbox_starter);

# Trennlinie in hbox
my $hbox_seperator = Gtk2::VSeparator->new;
$hbox->pack_start($hbox_seperator, TRUE, FALSE, 5);
$hbox_seperator->show;

# create vbox for hardware
my $hbox_hardware = Gtk2::VBox->new(FALSE, 5);
$hbox_hardware->set_border_width(0);
# insert vbox into window
$hbox->add($hbox_hardware);
$hbox_hardware->show;


############################################################
# add vbox_hardware inside hbox_hardware and fill it:
# hardware_grafik, hardware_ram 
############################################################

############################################################
# grafik radiobuttons
############################################################
# hardware_grafik
my $vbox_hardware = Gtk2::VBox->new(FALSE, 5);
$vbox_hardware->set_border_width(0);
$hbox_hardware->add($vbox_hardware);

my $hardware_grafik = Gtk2::Frame->new();
$hardware_grafik->set_shadow_type ('out');
$hardware_grafik->set_border_width(10);
$hardware_grafik->set_label("  Virtuelle Grafik:  ");
$vbox_hardware->pack_start($hardware_grafik,TRUE,TRUE,5);
$hardware_grafik->show;

my $grafik_v_stock = Gtk2::VBox->new(FALSE,5);
$grafik_v_stock->set_border_width(15);
&create_radiobuttons("GRAFIK",
                     $grafik_v_stock, 
                     $grafik_buttons_default,
                     @grafik_buttons);
$hardware_grafik->add($grafik_v_stock);
$vbox_hardware->show_all();


############################################################
# ram radiobuttons
############################################################
# hardware_ram
$vbox_hardware = Gtk2::VBox->new(FALSE, 5);
$vbox_hardware->set_border_width(0);
$hbox_hardware->add($vbox_hardware);

my $hardware_ram = Gtk2::Frame->new();
$hardware_ram->set_shadow_type ('out');
$hardware_ram->set_border_width(10);
$hardware_ram->set_label("  Virtueller Arbeitsspeicher (RAM):  ");
$vbox_hardware->pack_start($hardware_ram,TRUE,TRUE,5);
$hardware_ram->show;

my $ram_v_stock = Gtk2::VBox->new(FALSE,5);
$ram_v_stock->set_border_width(15);
&create_radiobuttons("RAM",
                     $ram_v_stock, 
                     $ram_buttons_default,
                     @ram_buttons);
$hardware_ram->add($ram_v_stock);
$vbox_hardware->show_all();

# rows, columns, homogeneous
my $table = Gtk2::Table->new(2, 3, FALSE);
$vbox->pack_start($table, FALSE, TRUE, 0);
$table->show;

# is shown by base image restorer
#$app_window->show;

Gtk2->main;

0;




############################################################
# subs
############################################################

sub get_vbox_uuid {
    my ($vm) = @_;
    my $path=$vm{$vm};
    $path=$path."/Snapshots";
    my $vbox_uuid="";
    opendir SNAP, $path;
    foreach my $machine (readdir SNAP){
        if ($machine eq "."){next};
        if ($machine eq ".."){next};
        $machine=~s/}.vdi$//g;
        $machine=~s/^{//g;
        $vbox_uuid=$machine;
    }
    closedir SNAP;
    return $vbox_uuid;
}


sub fix_vbox_permissions {
    my ($abs_path) = @_;
    #my $abs_file=$abs_path."/".$vm.".vbox";
    print "Fixing permissions with sudoers script\n";
    my $command="sudo /usr/bin/leoclient2-set-permissions";
    print "$command\n";
    system($command);
}

sub get_machine_path {
    my ($machine) = @_;
    my $machine_abs=$conf_machines."/".$machine;
    my $path=`cat $machine_abs`;
    chomp($path);
    return $path;
}


sub check_base_image {
    my ($home,$on_the_go) = @_;
    my $get_it=0;
    my $target_dir = dirname($base_image_target);
    my $base_image_on_the_go=$snapshot_search_dir_client.
                             "/".
                             $base_image_source.
                             ".zip";
    if (-e "$base_image_target"){
        my $size = -s $base_image_target;
        #print "$size  $base_image_size\n";
        if ($size ne $base_image_size){
            $get_it=1;
        } else {
            $app_window->show;
        }
    } else {
        $get_it=1;
        if (-d $target_dir){
            # nothing to do
        } else {
            print "Could not find $target_dir on your system:\n";
            my $message="<b>Das Verzeichnis $target_dir konnte nicht gefunden werden!\n\n".
		        "   Bitte starten Sie den Rechner neu\n".
                        "   und synchronisiren dann alle Partitionen!</b>";
            system("/usr/bin/zenity --error --text='$message'");
            exit;
        } 
    }
    if ($get_it==1){
	&get_zipped_basefile($base_image_target);
    }
}



sub get_zipped_basefile {
    my ($target) = @_;
    my $target_dir = dirname($base_image_target);
    my $base_image_on_the_go=$snapshot_search_dir_client.
                             "/".
                             $base_image_source.
                             ".zip";
    $pb_win_get_base_zip = Gtk2::Window->new('toplevel');
    $pb_win_get_base_zip->set_title("Entpacke Windows Basis Image");
    $pb_win_get_base_zip->set_border_width(20);
    # Fenstergroesse
    $pb_win_get_base_zip->set_size_request( 900, 70 );
    # zentrieren
    $pb_win_get_base_zip->set_position('center_always');
    $pb_win_get_base_zip->show;
    my $progress_bar = Gtk2::ProgressBar->new;
    $pb_win_get_base_zip->{pbar} = $progress_bar;
    $pb_win_get_base_zip->add($progress_bar);
    # movement from left to right
    $progress_bar->{activity_mode} = 0;
    $progress_bar->show;
    # Add a timer callback to update the value of the progress bar
    $progress_bar->{timer} = Glib::Timeout->add(500, 
                                         \&unzip_base_timeout, 
                                         $progress_bar);
    system("cd $target_dir; unzip -o '$base_image_on_the_go'|| sudo unzip -o '$base_image_on_the_go' &");
}



sub unzip_base_timeout {
    my $actual_size;
    my $unzipped_size=$base_image_size;
    my $unzipped_size_mb=int($unzipped_size/1024/1024);
    my $file=$base_image_target;
    my $progress_bar = shift;
    # Calculate the value of the progress bar using the
    # value range set in the adjustment object
    $actual_size = -s $file;
    my $new_val = $actual_size/$unzipped_size;
    $actual_size=int($actual_size/1024/1024);

    # check if done
    if ($new_val == 1.0){
        $progress_bar->set_fraction($new_val);
        $progress_bar->set_text('Fertig!');
        $pb_win_get_base_zip->destroy;
        $app_window->show;
        return FALSE;
    }
    # Set the new value
    $progress_bar->set_text("Entpacke ... $actual_size von $unzipped_size_mb MB");
    # make it 10% faster
    $new_val=1.1*$new_val;
    if ($new_val>=1){
        $new_val=1;
    }
    $progress_bar->set_fraction($new_val);

    # As this is a timeout function, return TRUE so that it
    # continues to get called
    return TRUE;
}



sub starter_vbox {
    # The starter Window
    my $hand_cursor = Gtk2::Gdk::Cursor->new ('hand2');
    #create a Gtk2::VBox to pack a Gtk2::Frame in. The frame will contain
    #a Gtk2::ScrolledWindow, which in turn will contain a Gtk2::VBox full
    #of Gtk2::Buttons
    my $sw;
    my $vbox = Gtk2::VBox->new(FALSE,5);
    my $frame = Gtk2::Frame->new();
    $frame->set_shadow_type ('out');
    #method of Gtk2::Container
    $frame->set_border_width(2);
    $frame->set_label("  Wählen Sie das virtuelle Windows aus:  ");
    $sw = Gtk2::ScrolledWindow->new (undef, undef);
    $sw->set_shadow_type ('etched-out');
    $sw->set_policy ('never', 'automatic');
    #This is a method of the Gtk2::Widget class,it will force a minimum 
    #size on the widget. Handy to give intitial size to a 
    #Gtk2::ScrolledWindow class object
    $sw->set_size_request (300, 500);
    #method of Gtk2::Container
    $sw->set_border_width(10);
    #create a vbox that will contain all the stock buttons
    my $vbox_stock = Gtk2::VBox->new(FALSE,5);
    $vbox_stock->set_border_width(10);
    &create_radiobuttons("SYSTEM",
                         $vbox_stock, 
                         $buttons_as_used,
                         @buttons);
    # add the vbox with all the stock buttons	
    $sw->add_with_viewport($vbox_stock);
    $frame->add($sw); 
    #$frame->add($vbox_stock);
    $vbox->pack_start($frame,TRUE,TRUE,4);

    # add the big start button
    my $start_button = Gtk2::Button->new("Starten!");
    $start_button->set_alignment (0.5, 0.5);
    $start_button->signal_connect(clicked => \&start_button, $start_button);
    $vbox->pack_start($start_button, FALSE, FALSE, 0);
    $start_button->show;
    $vbox->show_all();
    return $vbox;
}



sub progress_timeout {
	my $progress_bar = shift;
	if ($progress_bar->{activity_mode}){
	    $progress_bar->pulse;
	} else {
	    # Calculate the value of the progress bar using the
	    # value range set in the adjustment object
	    my $new_val = $progress_bar->get_fraction() + 0.01;
		
            if ($new_val > 1.0){
                $progress_bar->set_text('Entpacke  ...');
                $new_val = 0.0;
            }
	    # Set the new value 
            # make it faster
            #$new_val=1.1*$new_val;
            #if ($new_val>=1){
            #    $new_val=1;
            #}
	    $progress_bar->set_fraction($new_val);
	}

	# As this is a timeout function, return TRUE so that it
	# continues to get called
	return TRUE;
}



# Remove the timer
sub destroy_progress {
	my $app_window = shift;
	Glib::Source->remove($app_window->{pbar}->{timer});
	Gtk2->main_quit;
}



# The big start button
sub start_button {
    my ($window, $name) = @_;
    # what to start
    INFO "########## Start-Button pressed:  ##########";
    INFO "   RAM:    $selected{'RAM'}";
    INFO "   GRAFIK: $selected{'GRAFIK'}";
    INFO "   SYSTEM: $selected{'SYSTEM'}";
    # check if existing file is OK
       # copy
       # copy not needed
    if ($selected{'SYSTEM'} eq $buttons_as_used){
        if ($virtualbox==1){
            my $start_vbox=$vm_path_export."/usr/bin/virtualbox";
            INFO "$start_vbox\n";
            system("$start_vbox");
            INFO "VirtualBox started in other window: Terminating here!";
        } else {
            my $remove_shared_folder=$vm_path_export.
               "/usr/bin/VBoxManage sharedfolder remove $vm --name home";
            INFO "$remove_shared_folder";
            system($remove_shared_folder);
            my $add_shared_folder=$vm_path_export.
               "/usr/bin/VBoxManage sharedfolder add $vm ".
               "--name home --hostpath $shared_home_abs";
            INFO "$add_shared_folder";
            system($add_shared_folder);
            my $command_mod = $vm_path_export.
                              "/usr/bin/VBoxManage modifyvm $vm".
                              " --memory $selected{'RAM'}";
            INFO "$command_mod";
            system($command_mod);
            my $start_vm = $vm_path_export.
                           "/usr/bin/VBoxManage startvm $vm --type gui";
            INFO "$start_vm";
            system("$start_vm");
            INFO "Snapshot started in other window: Terminating here!";
        }
        exit;
    } else {
        # get the zipped snapshot
        my $zipped_snapshot_file = &get_zipped_snapshot($selected{'SYSTEM'});
    }
}



sub start_zipped_snaphot {
    my ($zipped_snapshot_file) = @_;
    #print Dumper(\%selected);

    if ($zipped_snapshot_file ne "___NOSNAPSHOT___"){
        INFO "unzip $zipped_snapshot_file ";
        INFO "to    $selected{'CACHE-ZIP'} ";

        $pb_win_start_zip = Gtk2::Window->new('toplevel');
        $pb_win_start_zip->set_title("Entpacke Windows: '$selected{'SYSTEM'}'");
        $pb_win_start_zip->set_border_width(20);
        # Fenstergroesse
        $pb_win_start_zip->set_size_request( 700, 70 );
        # zentrieren
        $pb_win_start_zip->set_position('center_always');
        $pb_win_start_zip->show;

        my $progress_bar = Gtk2::ProgressBar->new;
        $pb_win_start_zip->{pbar} = $progress_bar;
        $pb_win_start_zip->add($progress_bar);
        # movement from left to right
        $progress_bar->{activity_mode} = 0;
        # hin und her
        #$progress_bar->{activity_mode} = 1;
        $progress_bar->show;
        # Add a timer callback to update the value of the progress bar
        $progress_bar->{timer} = Glib::Timeout->add(500, 
                                             \&unzip_timeout, 
                                             $progress_bar);
   
        my $command_prep="mkdir -p $snapshot_file_dir || ".
                      "sudo mkdir -p $snapshot_file_dir";
        INFO "$command_prep";
        system("$command_prep");

        my $command_unzip="cd $snapshot_file_dir; ".
	                  "unzip -o '$zipped_snapshot_file' &";

        INFO "$command_unzip";
        system("$command_unzip");
        
        my $unzipped_actual_size=0;
        my $unzipped_size=$snapshots{$selected{'SYSTEM'}}{'filesize_vdi'};
    } else {

    }
    #exit;
}



sub unzip_timeout {
    my $actual_size;
    my $unzipped_size=$snapshots{$selected{'SYSTEM'}}{'filesize_vdi'};
    my $unzipped_size_mb=int($unzipped_size/1024/1024);
    my $file=$snapshot_file_dir."/".$snapshot_file_name;
    my $progress_bar = shift;
    # Calculate the value of the progress bar using the
    # value range set in the adjustment object
    $actual_size = -s $file;
    if (not defined $actual_size){
        $actual_size=0;
    }
    my $new_val = $actual_size/$unzipped_size;
    $actual_size=int($actual_size/1024/1024);

    # check if done
    if ($new_val == 1.0){
        $progress_bar->set_fraction($new_val);
        $progress_bar->set_text('Fertig!');
        $pb_win_start_zip->destroy;
        # modifying virtual machine
        system("chmod 777 $file");
        if ($virtualbox==1){
            my $start_vbox=$vm_path_export."/usr/bin/virtualbox";
            INFO "Executing: $start_vbox\n";
            system("$start_vbox");
            INFO "VirtualBox started in other window: Terminating here!";
        } else {
            my $remove_shared_folder=$vm_path_export.
                "/usr/bin/VBoxManage sharedfolder remove $vm --name home";
            INFO "$remove_shared_folder";
            system($remove_shared_folder);
            my $add_shared_folder=$vm_path_export.
               "/usr/bin/VBoxManage sharedfolder add $vm ".
               "--name home --hostpath $shared_home_abs";
            INFO "$add_shared_folder";
            system($add_shared_folder);
            my $command_mod = $vm_path_export.
                              "/usr/bin/VBoxManage modifyvm $vm".
                              " --memory $selected{'RAM'}";
            INFO "Executing: $command_mod\n";
            system($command_mod);
            my $start_vm=$vm_path_export.
                         "/usr/bin/VBoxManage startvm $vm --type gui";
            INFO "Executing: $start_vm\n";
            system("$start_vm");
            INFO "Snapshot started in other window: Terminating here!";
        }
        exit;
        return FALSE;
    }
    # Set the new value
    $progress_bar->set_text("Entpacke ... $actual_size von $unzipped_size_mb MB");
    # make it 10% faster
    $new_val=1.1*$new_val;
    if ($new_val>=1){
        $new_val=1;
    }
    $progress_bar->set_fraction($new_val);

    # As this is a timeout function, return TRUE so that it
    # continues to get called
    return TRUE;
}



sub getzip_timeout {
    my $actual_size;
    my $zipped_size=$snapshots{$selected{'SYSTEM'}}{'filesize_zipped'};
    my $zipped_size_mb=int($zipped_size/1024/1024);

    my $target = $selected{'CACHE-ZIP'};

    my $progress_bar_copy = shift;
    # Calculate the value of the progress bar using the
    # value range set in the adjustment object
    $actual_size = -s $target;

    my $new_val = $actual_size/$zipped_size;
    $actual_size=int($actual_size/1024/1024);
    $progress_bar_copy->set_text("Hole ... $actual_size von $zipped_size_mb MB");
    if ($new_val == 1.0){
        # Copying of zippd file done
        $progress_bar_copy->set_fraction($new_val);
        $progress_bar_copy->set_text('Fertig!');
        $pb_win_get_zip->destroy;
        $copying_done=1;
        INFO "Snapshot was copied to $target";
        system("chmod 777 $target");
        my $started=&start_zipped_snaphot($target);
        return FALSE;
    }
    # make it 10% faster
    $new_val=1.1*$new_val;
    if ($new_val>=1){
        $new_val=1;
    }
    # Set the new value
    $progress_bar_copy->set_fraction($new_val);

    # As this is a timeout function, return TRUE so that it
    # continues to get called
    return TRUE;
}



sub get_zipped_snapshot {
    # returns absolute path of zipped file in cache
    my ($snapshot) = @_;
    if ($snapshot eq $buttons_default){
       # This is the default snapshot, do what is configured as default/standard
	$snapshot=$snapshot_default;
        $selected{'SYSTEM'}=$snapshot;
    } elsif ($snapshot eq $buttons_as_used){
        # start as found
        #my $started=&start_zipped_snaphot($selected{'CACHE-ZIP'});
        #my $started=&start_zipped_snaphot("___NOSNAPSHOT___");
        #return "___NOSNAPSHOT___";  
    } elsif (not defined $snapshots{$snapshot}{'abs_path'}){
        
    }

    # zipped snapshot must be fetched
    # generate paths
    my $file=$snapshots{$snapshot}{'abs_path'};
    my $dir =$snapshots{$snapshot}{'abs_dir'};
    my $file_zipped=$file.".zip";
    my $filesize_file_zipped = $dir."/filesize.vdi.zipped";

    my $filesize_correct=`cat '$filesize_file_zipped'`;
    chomp($filesize_correct);
    my $filesize_correct_mb=int((1.1*$filesize_correct)/(1024*1024));

    INFO "Wanted in cache with size $filesize_correct:\n   $file_zipped";
    
    if($#cache_dirs==-1){
        INFO "ERROR: No cache configured in $cache_conf_path";
        print "ERROR: No cache configured in $cache_conf_path\n";
    }

    # is snapshot in cache already and size OK?
    foreach my $dir (@cache_dirs){
        my $file=$dir."/".$snapshot."/".$snapshot_file_name.".zip";
        my $target_dir = $dir."/".$snapshot;
        my $target=$target_dir."/".$snapshot_file_name.".zip";
        # save target
        $selected{'CACHE-ZIP'}=$target;
        INFO "CACHE-ZIP: $selected{'CACHE-ZIP'}";

	INFO "Checking for existance in $dir:\n   $file";
	if (-e $file){
            INFO "Snapshot found: $dir";
            my $actual_size = -s $file;
            if ($actual_size==$filesize_correct){
                INFO  "Snapshot size correct ($actual_size) --> using it:";
                my $started=&start_zipped_snaphot($selected{'CACHE-ZIP'});
                return $started;
            }
	}
    }

    # snapshot is not in cache

    # copy snapshot into cache
    my $count=0;
    foreach my $dir (@cache_dirs){
        # go through all caches, check if there is enough space left
        my $target_dir = $dir."/".$snapshot;
        my $target=$target_dir."/".$snapshot_file_name.".zip";
        INFO "*** : $target";
        # save target
        $selected{'CACHE-ZIP'}=$target;
        INFO "   CACHE-ZIP: $selected{'CACHE-ZIP'}";
        # check if files must be deleted (obey cache size limit ) 
        my $cache_used = &get_size_in_mb($dir);
        my $cache=$cache_used+int($filesize_correct/(1024*1024));
        my ($space_left_mb) = &get_space_left($dir);

        INFO "*** Cache limit:                ",
             "$cache_dirs_size[$count] MB";
        INFO "*** Cache used so far:            $cache_used MB";
        INFO "*** Cache needed with new file:   $cache MB";
        INFO "*** Space left :                  $space_left_mb MB";
        INFO "*** Zip-file (incl 10\% reserve): $filesize_correct_mb MB";

        # check available space
        while ($cache >= $cache_dirs_size[$count]
               or $filesize_correct_mb >= $space_left_mb){
            INFO "*** --> cache files must be deleted";
            my @oldest_in_cache = &oldest_in_cache($dir);
            if (not defined $oldest_in_cache[0]){
                # define it to avois errors
                $oldest_in_cache[0]="_____nonsense_____";
            }
            my $oldest=$dir."/".$oldest_in_cache[0];
            if (-d $oldest ){
                # delete file here
                INFO "*** Deleting: $oldest";
                system("rm -rf '$oldest'");
                $cache_used = &get_size_in_mb($dir);
                $cache=$cache_used+int($filesize_correct/(1024*1024));
                ($space_left_mb) = &get_space_left($dir);

                INFO "*** Cache limit:                ",
                     "$cache_dirs_size[$count] MB";
                INFO "*** Cache used so far:            $cache_used MB";
                INFO "*** Cache needed with new file:   $cache MB";
                INFO "*** Space left :                  $space_left_mb MB";
                INFO "*** Zip-file (incl 10\% reserve): $filesize_correct_mb MB";
            } else {
                INFO "Nothing to delete!";
                # exit from while
                last;
	    }
        }        

        # copy snapshot if enough space
        ($space_left_mb) = &get_space_left($dir);
        if ($space_left_mb > 10+int($filesize_correct/(1024*1024))){

            system("mkdir -p '$target_dir'");
            # window erstellen
            $pb_win_get_zip = Gtk2::Window->new('toplevel'); 
            $pb_win_get_zip->set_title("Hole gezipptes Windows: '$selected{'SYSTEM'}'");
            $pb_win_get_zip->set_border_width(20);
            # Fenstergroesse
            $pb_win_get_zip->set_size_request( 700, 70 );
            # zentrieren
            $pb_win_get_zip->set_position('center_always');
            $pb_win_get_zip->show;

            my $progress_bar = Gtk2::ProgressBar->new;
            # wozu?
            $pb_win_get_zip->{pbar} = $progress_bar;
            $pb_win_get_zip->add($progress_bar);
            # movement from left to right
            $progress_bar->{activity_mode} = 0;
            # hin und her
            #$progress_bar->{activity_mode} = 1;
            $progress_bar->show;
            # Add a timer callback to update the value of the progress bar
            $progress_bar->{timer} = Glib::Timeout->add(500, 
                                             \&getzip_timeout, 
                                             $progress_bar);
            INFO "* cp $file_zipped";
            INFO "* -> $target ...";
            system("cp -v '$file_zipped' '$target' &");
            INFO "* ... done!";
            return $target;
            #my $actual_size = -s $target;
            #if (defined $actual_size and $actual_size==$filesize_correct){
            #    INFO "*** Snapshot size correct!";
            #    return $target;
            #}
        } else {
            INFO "Could not find space to cache $file";
        }# end if $space_left_mb > 10+int ...
        $count++;
    }
}



sub get_space_left {
    my ($dir) = @_;
    my $space_left_mb=0;
    my $space_left=0;
    # using Filesys::Df
    my $ref = df($dir);
    if (defined $ref){
        $space_left=$ref->{bavail};
    }
    $space_left_mb=int($space_left/1024);
    INFO "*** $space_left_mb MB left in $dir";
    return $space_left_mb;
}



sub oldest_in_cache {
    my ($dir) = @_;
    my $result=`ls -Atr1 '$dir'`;
    my @list = split(/\n/,$result);
    foreach my $item (@list){
        INFO "List:  >$item<";
    }
    return @list;
}



sub get_size_in_mb {
    # return size of dir in MB
    my ($dir) = @_;
    my $string=`du -ms '$dir'`;
    my ($size,$rest)=split(/\s/,$string);
    return $size;
}



sub create_radiobuttons {
    # string under which to save selected value in %selected
    # widget to which radiobuttons will be added
    # default button ('no button' = do not show a default button)
    # more buttons
    my ($type,$radio_box,$default,@buttons) = @_;
    $selected{$type}=$default;
    my @radiobutton;
    my @group;

    my $i=0; # counter for DISPLAYED buttons
    # add the buttons from the list
    foreach my $button ( @buttons ){
        my $button_name;
        # $button: dirname
        # $snaphots{$button}
	INFO "Checking for button $button";
        my $displayname="---";
        my $host_string="";
        my $host_check=0; # default: no check
        my $room_string="";
        my $room_check=0; # default: no check
        if (exists $snapshots{$button}{'name'}){
 	    INFO "   * Name:       ",
                 "$snapshots{$button}{'name'}";
            $displayname=$snapshots{$button}{'name'};
        } else {
            $displayname=$button;
        }
        if (exists $snapshots{$button}{'maintainer'}){
 	    INFO "   * Maintainer: ",
                 "$snapshots{$button}{'maintainer'}";
            $displayname=$displayname.
                " (".$snapshots{$button}{'maintainer'}.")";
        }
        if (exists $snapshots{$button}{'host'}){
            $host_string=$snapshots{$button}{'host'};
            $host_check=1; # check for hosts later
 	    INFO "   * Hosts allowed:";
            my @hosts = split(/,/,$host_string);
            foreach my $host (@hosts){
    	        INFO "      * $host";
                $snapshots{$button}{'hosts'}{$host}="OK";
            }
        }
        if (exists $snapshots{$button}{'room'}){
            $room_string=$snapshots{$button}{'room'};
            $room_check=1; # check for rooms later
            my @rooms = split(/,/,$room_string);
    	        INFO "   * Rooms allowed";
            foreach my $room (@rooms){
    	        INFO "      * $room";
                $snapshots{$button}{'rooms'}{$room}="OK";
            }
        }



        # check if button should be displayed        
        ########################################
        my $room_check_ok=1; # default: display 
        my $host_check_ok=1; # default: display

        if ($room_check==1){
          if (exists $snapshots{$button}{'rooms'}{$host_room}){
	      INFO "Room $host_room is ",
                   "$snapshots{$button}{'rooms'}{$host_room}";
          } else {
              INFO "Room >$host_room< not found as allowed room";
              $room_check_ok=0; 
          }
        }

        if ($host_check==1){
          # hostname on a linbo client can have an -w added at the end
          # when synchronizing has failed
	  my $alternate_linbo_hostname=$hostname;
          $alternate_linbo_hostname=~s/-w$//g;
          if (exists $snapshots{$button}{'hosts'}{$hostname}
                  or $snapshots{$button}{'hosts'}{$alternate_linbo_hostname}){
	      INFO "Host $hostname is ",
                   "$snapshots{$button}{'hosts'}{$hostname}";
	      INFO "Linbo Host $alternate_linbo_hostname is ",
                   "$snapshots{$button}{'hosts'}{$alternate_linbo_hostname}";
          } else {
              INFO "Host >$hostname< not found as allowed host";
              INFO "Linbo Host >$alternate_linbo_hostname< not found as allowed host";
              $host_check_ok=0; 
          }
        }

        if ($room_check_ok==0 and $host_check_ok==0){
            # beide checks ohne Erfolg
            next;
        }



        if ($type eq "RAM"){
            if (exists $ram_mapping{$button}){
                $button_name=$ram_mapping{$button};
            } else {
                $button_name=$button;
            }
        } else {
                # $button: dirname
                # $displayname: name in image.conf
                $button_name=$displayname;
        } 
        if ($i==0){
            # this is the first button
            $radiobutton[$i] = Gtk2::RadioButton->new(undef, $button_name);
            $radio_box->pack_start($radiobutton[0], FALSE, TRUE, 5);
            $radiobutton[$i]->signal_connect (clicked => sub {
                   ($selected{$type} = $button); 
                  });
            $radiobutton[$i]->show;
            if ($type eq "RAM"){
                my $sep = Gtk2::HSeparator->new;
                $radio_box->pack_start($sep, FALSE, FALSE, 3);
                $sep->show;
	    }
        } else {
            # just another button
            @group = $radiobutton[0]->get_group;
            $radiobutton[$i] = Gtk2::RadioButton->new_with_label(@group,
                               "$button_name");
            $radiobutton[$i]->set_active(FALSE);
            # $radiobutton[$i]->signal_connect (clicked => sub {
            # ($radiobutton[$i]->get_active) and ($selected_system = $button); 
            $radiobutton[$i]->signal_connect (clicked => sub {
                         ($selected{$type} = $button); 
                  });
            $radio_box->pack_start($radiobutton[$i],FALSE,FALSE,4);
        }
        $i++;
    }
}



sub ram_sizes {
    my $error_default="512 MB";
    my $mem_kb=`cat /proc/meminfo | grep MemTotal:`;
    $mem_kb=~m/([0-9]+)/;
    my $mem_mb=int($1/1024);
    my $last_diff_size=100000;
    my $last_size;
    my @display_size=();
    my $list_count=0;
    DEBUG "Host memory size: $mem_mb";
    foreach my $size ( @ram_steps ){
        DEBUG "Is $size ok for $mem_mb ?";
        my $diff_size=abs((0.5*$mem_mb)-$size);
        DEBUG "$diff_size > $last_diff_size ($size MB)";        
        if ($diff_size > $last_diff_size or
            $size >$max_guest_ram){
            last;            
        }
        $last_diff_size=$diff_size;
        $last_size=$size;
        $list_count++;
    }
    my $pre=$list_count-2;
    my $fix=$list_count-1;
    my $post=$list_count-0;
    INFO "        RAM size: $ram_steps[$pre] MB (".$pre.")";
    INFO "Perfect RAM size: $ram_steps[$fix] MB (: ".$fix.")";
    INFO "        RAM size: $ram_steps[$post] MB (: ".$post.")";

    @display_size=(
               $ram_steps[$fix],
               $ram_steps[$pre]
                  );
    if ($ram_steps[$post]<=$max_guest_ram){
        push @display_size, $ram_steps[$post];
    }
    return $ram_steps[$fix],@display_size;
}





# subs from pm:


sub  check_options{
   my ($parse_ergebnis) = @_;
   if (not $parse_ergebnis==1){
      my @list = split(/\//,$0);
      my $scriptname = pop @list;
      print "\nYou have made a mistake, when specifying options.\n"; 
      print "See error message above. \n\n";
      print "... $scriptname is terminating.\n\n";
      exit;
   } else {
      print "All options  were recognized.\n";
   }

}




sub test {
    print "Sub test from module leovirtstarter\n";
}




sub show_message_dialog {
    #THIS IS THE MAIN FEATURE OF THE APP:
    #you tell it what to display, and how to display it
    #$parent is the parent window, or "undef"
    #$icon can be one of the following:	a) 'info'
    #					b) 'warning'
    #					c) 'error'
    #					d) 'question'
    #$text can be pango markup text, or just plain text, IE the message
    #$button_type can be one of the following: 	a) 'none'
    #						b) 'ok'
    #						c) 'close'
    #						d) 'cancel'
    #						e) 'yes-no'
    #						f) 'ok-cancel'

    my ($parent,$icon,$text,$button_type) = @_;
 
    my $dialog = Gtk2::MessageDialog->new_with_markup ($parent,
					[qw/modal destroy-with-parent/],
					$icon,
					$button_type,
					sprintf "$text");
		
    # this will typically return certain values depending on the 
    # value of $retval.
    # in this application, we only change the label's value accordingly
    my $retval = $dialog->run;
    #destroy the dialog as it comes out of the 'run' loop	
    $dialog->destroy;
}



sub get_snapshots {
    my @snapshots=();
    my @dirs = @_;
    foreach my $dir (@dirs){
        # append vm name
        my $get_dir=$dir."/".$vm."/snapshot-store";

        if (not -d $get_dir){
            print "WARNING: Nonexisting Snapshot search dir: $get_dir\n";
            return @snapshots;
        }
        print "opening $get_dir\n";
        opendir (DIR, $get_dir) || die $!;
        while( (my $dirname = readdir(DIR))){
            if ($dirname eq "." or $dirname eq ".." ){
	        next;
            }
            print "Processing $dirname\n";
            my $abs_path=$get_dir."/".
                         $dirname."/".$snapshot_file_name;
            if (not -e $abs_path){
                # no snapshot file found/no access to snapshot file 
                next;
            }
            ${snapshots}{$dirname}{'abs_path'}=$abs_path;
            my $abs_dir = $get_dir."/".
                          $dirname;
            ${snapshots}{$dirname}{'abs_dir'}=$abs_dir;

            # filesizes
            my $file_vdi_size=$abs_dir."/filesize.vdi";
            my $file_zipped_size=$abs_dir."/filesize.vdi.zipped";
            my $filesize_vdi=`cat '$file_vdi_size'`;
            chomp($filesize_vdi);
            my $filesize_zipped=`cat '$file_zipped_size'`;
            chomp($filesize_zipped);
            ${snapshots}{$dirname}{'filesize_vdi'}=$filesize_vdi;
            ${snapshots}{$dirname}{'filesize_zipped'}=$filesize_zipped;

            if ($dirname ne $snapshot_default){
                # jump over the default snapshot 
                # (appears automagically at second in the list)
                push @snapshots, $dirname;
            }

            # read image.conf
            my $file=$get_dir."/".$dirname."/image.conf";
            if (-e $file){
                open (FILE, $file);
	        while (<FILE>){
                    chomp();
                    my ($key,$value) = split(/=/);
                    # convert unicode to iso
                    $value=~s/\303\244/\344/g;# ae
                    $value=~s/\303\204/\304/g;# Ae
                    $value=~s/\303\266/\366/g;# oe
                    $value=~s/\303\226/\326/g;# Oe
                    $value=~s/\303\274/\374/g;# ue
                    $value=~s/\303\234/\334/g;# Ue
                    $value=~s/\303\237/\337/g;# ss

                    ${snapshots}{$dirname}{$key}="$value";
                    #print "   * Key: $key  --> Value: $value\n";
	        }
                close FILE;
            }
        }
        closedir DIR;
    }
    @snapshots = sort @snapshots;
    return @snapshots;
}





